"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[429],{253:(xe,Ge,Ne)=>{const He=":";const ct=function(s,...o){if(ct.translate){const P=ct.translate(s,o);s=P[0],o=P[1]}let _=lt(s[0],s.raw[0]);for(let P=1;P<s.length;P++)_+=o[P-1]+lt(s[P],s.raw[P]);return _},ut=":";function lt(s,o){return o.charAt(0)===ut?s.substring(function F(s,o){for(let _=1,P=1;_<s.length;_++,P++)if("\\"===o[P])P++;else if(s[_]===He)return _;throw new Error(`Unterminated $localize metadata block in "${o}".`)}(s,o)+1):s}globalThis.$localize=ct,Ne(332),Ne(854)},854:()=>{const xe="\n",Ge={},Ne="__creationTrace__",He="STACKTRACE TRACKING",et="__SEP_TAG__";let Be=et+"@[native]";class We{constructor(){this.error=Ve(),this.timestamp=new Date}}function Oe(){return new Error(He)}function tt(){try{throw Oe()}catch(a){return a}}const Me=Oe(),je=tt(),Ve=Me.stack?Oe:je.stack?tt:Oe;function Qe(a){return a.stack?a.stack.split(xe):[]}function nt(a,r){let g=Qe(r);for(let l=0;l<g.length;l++)Ge.hasOwnProperty(g[l])||a.push(g[l])}function ue(a,r){const g=[r?r.trim():""];if(a){let l=(new Date).getTime();for(let m=0;m<a.length;m++){const y=a[m],I=y.timestamp;let T=`____________________Elapsed ${l-I.getTime()} ms; At: ${I}`;T=T.replace(/[^\w\d]/g,"_"),g.push(Be.replace(et,T)),nt(g,y.error),l=I.getTime()}}return g.join(xe)}function Ue(){return Error.stackTraceLimit>0}function Fe(a,r){r>0&&(a.push(Qe((new We).error)),Fe(a,r-1))}Zone.longStackTraceZoneSpec={name:"long-stack-trace",longStackTraceLimit:10,getLongStackTrace:function(a){if(!a)return;const r=a[Zone.__symbol__("currentTaskTrace")];return r?ue(r,a.stack):a.stack},onScheduleTask:function(a,r,g,l){if(Ue()){const m=Zone.currentTask;let y=m&&m.data&&m.data[Ne]||[];y=[new We].concat(y),y.length>this.longStackTraceLimit&&(y.length=this.longStackTraceLimit),l.data||(l.data={}),"eventTask"===l.type&&(l.data={...l.data}),l.data[Ne]=y}return a.scheduleTask(g,l)},onHandleError:function(a,r,g,l){if(Ue()){const m=Zone.currentTask||l.task;if(l instanceof Error&&m){const y=ue(m.data&&m.data[Ne],l.stack);try{l.stack=l.longStack=y}catch{}}}return a.handleError(g,l)}},function pe(){if(!Ue())return;const a=[];Fe(a,2);const r=a[0],g=a[1];for(let l=0;l<r.length;l++){const m=r[l];if(-1==m.indexOf(He)){let y=m.match(/^\s*at\s+/);if(y){Be=y[0]+et+" (http://localhost)";break}}}for(let l=0;l<r.length;l++){const m=r[l];if(m!==g[l])break;Ge[m]=!0}}();class $e{static get(){return Zone.current.get("ProxyZoneSpec")}static isLoaded(){return $e.get()instanceof $e}static assertPresent(){if(!$e.isLoaded())throw new Error("Expected to be running in 'ProxyZone', but it was not found.");return $e.get()}constructor(r=null){this.defaultSpecDelegate=r,this.name="ProxyZone",this._delegateSpec=null,this.properties={ProxyZoneSpec:this},this.propertyKeys=null,this.lastTaskState=null,this.isNeedToTriggerHasTask=!1,this.tasks=[],this.setDelegate(r)}setDelegate(r){const g=this._delegateSpec!==r;this._delegateSpec=r,this.propertyKeys&&this.propertyKeys.forEach(l=>delete this.properties[l]),this.propertyKeys=null,r&&r.properties&&(this.propertyKeys=Object.keys(r.properties),this.propertyKeys.forEach(l=>this.properties[l]=r.properties[l])),g&&this.lastTaskState&&(this.lastTaskState.macroTask||this.lastTaskState.microTask)&&(this.isNeedToTriggerHasTask=!0)}getDelegate(){return this._delegateSpec}resetDelegate(){this.getDelegate(),this.setDelegate(this.defaultSpecDelegate)}tryTriggerHasTask(r,g,l){this.isNeedToTriggerHasTask&&this.lastTaskState&&(this.isNeedToTriggerHasTask=!1,this.onHasTask(r,g,l,this.lastTaskState))}removeFromTasks(r){if(this.tasks)for(let g=0;g<this.tasks.length;g++)if(this.tasks[g]===r)return void this.tasks.splice(g,1)}getAndClearPendingTasksInfo(){if(0===this.tasks.length)return"";const g="--Pending async tasks are: ["+this.tasks.map(l=>{const m=l.data&&Object.keys(l.data).map(y=>y+":"+l.data[y]).join(",");return`type: ${l.type}, source: ${l.source}, args: {${m}}`})+"]";return this.tasks=[],g}onFork(r,g,l,m){return this._delegateSpec&&this._delegateSpec.onFork?this._delegateSpec.onFork(r,g,l,m):r.fork(l,m)}onIntercept(r,g,l,m,y){return this._delegateSpec&&this._delegateSpec.onIntercept?this._delegateSpec.onIntercept(r,g,l,m,y):r.intercept(l,m,y)}onInvoke(r,g,l,m,y,I,T){return this.tryTriggerHasTask(r,g,l),this._delegateSpec&&this._delegateSpec.onInvoke?this._delegateSpec.onInvoke(r,g,l,m,y,I,T):r.invoke(l,m,y,I,T)}onHandleError(r,g,l,m){return this._delegateSpec&&this._delegateSpec.onHandleError?this._delegateSpec.onHandleError(r,g,l,m):r.handleError(l,m)}onScheduleTask(r,g,l,m){return"eventTask"!==m.type&&this.tasks.push(m),this._delegateSpec&&this._delegateSpec.onScheduleTask?this._delegateSpec.onScheduleTask(r,g,l,m):r.scheduleTask(l,m)}onInvokeTask(r,g,l,m,y,I){return"eventTask"!==m.type&&this.removeFromTasks(m),this.tryTriggerHasTask(r,g,l),this._delegateSpec&&this._delegateSpec.onInvokeTask?this._delegateSpec.onInvokeTask(r,g,l,m,y,I):r.invokeTask(l,m,y,I)}onCancelTask(r,g,l,m){return"eventTask"!==m.type&&this.removeFromTasks(m),this.tryTriggerHasTask(r,g,l),this._delegateSpec&&this._delegateSpec.onCancelTask?this._delegateSpec.onCancelTask(r,g,l,m):r.cancelTask(l,m)}onHasTask(r,g,l,m){this.lastTaskState=m,this._delegateSpec&&this._delegateSpec.onHasTask?this._delegateSpec.onHasTask(r,g,l,m):r.hasTask(l,m)}}Zone.ProxyZoneSpec=$e,Zone.SyncTestZoneSpec=class Xe{constructor(r){this.runZone=Zone.current,this.name="syncTestZone for "+r}onScheduleTask(r,g,l,m){switch(m.type){case"microTask":case"macroTask":throw new Error(`Cannot call ${m.source} from within a sync test (${this.name}).`);case"eventTask":m=r.scheduleTask(l,m)}return m}},Zone.__load_patch("jasmine",(a,r,g)=>{if(!r)throw new Error("Missing: zone.js");if(typeof jest<"u"||typeof jasmine>"u"||jasmine.__zone_patch__)return;jasmine.__zone_patch__=!0;const m=r.SyncTestZoneSpec,y=r.ProxyZoneSpec;if(!m)throw new Error("Missing: SyncTestZoneSpec");if(!y)throw new Error("Missing: ProxyZoneSpec");const I=r.current,T=r.__symbol__,v=!0===a[T("fakeAsyncDisablePatchingClock")],E=!v&&(!0===a[T("fakeAsyncPatchLock")]||!0===a[T("fakeAsyncAutoFakeAsyncWhenClockPatched")]);if(!0!==a[T("ignoreUnhandledRejection")]){const D=jasmine.GlobalErrors;D&&!jasmine[T("GlobalErrors")]&&(jasmine[T("GlobalErrors")]=D,jasmine.GlobalErrors=function(){const A=new D,k=A.install;return k&&!A[T("install")]&&(A[T("install")]=k,A.install=function(){const O=typeof process<"u"&&!!process.on,G=O?process.listeners("unhandledRejection"):a.eventListeners("unhandledrejection"),L=k.apply(this,arguments);return O?process.removeAllListeners("unhandledRejection"):a.removeAllListeners("unhandledrejection"),G&&G.forEach(Ee=>{O?process.on("unhandledRejection",Ee):a.addEventListener("unhandledrejection",Ee)}),L}),A})}const N=jasmine.getEnv();if(["describe","xdescribe","fdescribe"].forEach(D=>{let A=N[D];N[D]=function(k,O){return A.call(this,k,function V(D,A){return function(){return I.fork(new m(`jasmine.describe#${D}`)).run(A,this,arguments)}}(k,O))}}),["it","xit","fit"].forEach(D=>{let A=N[D];N[T(D)]=A,N[D]=function(k,O,G){return arguments[1]=S(O),A.apply(this,arguments)}}),["beforeEach","afterEach","beforeAll","afterAll"].forEach(D=>{let A=N[D];N[T(D)]=A,N[D]=function(k,O){return arguments[0]=S(k),A.apply(this,arguments)}}),!v){const D=jasmine[T("clock")]=jasmine.clock;jasmine.clock=function(){const A=D.apply(this,arguments);if(!A[T("patched")]){A[T("patched")]=T("patched");const k=A[T("tick")]=A.tick;A.tick=function(){const G=r.current.get("FakeAsyncTestZoneSpec");return G?G.tick.apply(G,arguments):k.apply(this,arguments)};const O=A[T("mockDate")]=A.mockDate;A.mockDate=function(){const G=r.current.get("FakeAsyncTestZoneSpec");if(G){const L=arguments.length>0?arguments[0]:new Date;return G.setFakeBaseSystemTime.apply(G,L&&"function"==typeof L.getTime?[L.getTime()]:arguments)}return O.apply(this,arguments)},E&&["install","uninstall"].forEach(G=>{const L=A[T(G)]=A[G];A[G]=function(){if(!r.FakeAsyncTestZoneSpec)return L.apply(this,arguments);jasmine[T("clockInstalled")]="install"===G}})}return A}}if(!jasmine[r.__symbol__("createSpyObj")]){const D=jasmine.createSpyObj;jasmine[r.__symbol__("createSpyObj")]=D,jasmine.createSpyObj=function(){const A=Array.prototype.slice.call(arguments);let O;if(A.length>=3&&A[2]){const G=Object.defineProperty;Object.defineProperty=function(L,Ee,Ye){return G.call(this,L,Ee,{...Ye,configurable:!0,enumerable:!0})};try{O=D.apply(this,A)}finally{Object.defineProperty=G}}else O=D.apply(this,A);return O}}function w(D,A,k,O){const G=!!jasmine[T("clockInstalled")],L=k.testProxyZone;if(G&&E){const Ee=r[r.__symbol__("fakeAsyncTest")];Ee&&"function"==typeof Ee.fakeAsync&&(D=Ee.fakeAsync(D))}return O?L.run(D,A,[O]):L.run(D,A)}function S(D){return D&&(D.length?function(A){return w(D,this,this.queueRunner,A)}:function(){return w(D,this,this.queueRunner)})}const F=jasmine.QueueRunner;jasmine.QueueRunner=function(D){function A(k){k.onComplete&&(k.onComplete=(Ee=>()=>{this.testProxyZone=null,this.testProxyZoneSpec=null,I.scheduleMicroTask("jasmine.onComplete",Ee)})(k.onComplete));const O=a[r.__symbol__("setTimeout")],G=a[r.__symbol__("clearTimeout")];O&&(k.timeout={setTimeout:O||a.setTimeout,clearTimeout:G||a.clearTimeout}),jasmine.UserContext?(k.userContext||(k.userContext=new jasmine.UserContext),k.userContext.queueRunner=this):(k.userContext||(k.userContext={}),k.userContext.queueRunner=this);const L=k.onException;k.onException=function(Ee){if(Ee&&"Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL."===Ee.message){const Ye=this&&this.testProxyZoneSpec;if(Ye){const it=Ye.getAndClearPendingTasksInfo();try{Ee.message+=it}catch{}}}L&&L.call(this,Ee)},D.call(this,k)}return function(D,A){for(const O in A)A.hasOwnProperty(O)&&(D[O]=A[O]);function k(){this.constructor=D}D.prototype=null===A?Object.create(A):(k.prototype=A.prototype,new k)}(A,D),A.prototype.execute=function(){let k=r.current,O=!1;for(;k;){if(k===I){O=!0;break}k=k.parent}if(!O)throw new Error("Unexpected Zone: "+r.current.name);this.testProxyZoneSpec=new y,this.testProxyZone=I.fork(this.testProxyZoneSpec),r.currentTask?D.prototype.execute.call(this):r.current.scheduleMicroTask("jasmine.execute().forceTask",()=>F.prototype.execute.call(this))},A}(F)}),Zone.__load_patch("jest",(a,r,g)=>{if(typeof jest>"u"||jest.__zone_patch__)return;r[g.symbol("ignoreConsoleErrorUncaughtError")]=!0,jest.__zone_patch__=!0;const l=r.ProxyZoneSpec,m=r.SyncTestZoneSpec;if(!l)throw new Error("Missing ProxyZoneSpec");const y=r.current,I=y.fork(new m("jest.describe")),T=new l,v=y.fork(T);function N(w){return function(...S){return I.run(w,this,S)}}function V(w,S=!1){if("function"!=typeof w)return w;const F=function(){if(!0===r[g.symbol("useFakeTimersCalled")]&&w&&!w.isFakeAsync){const D=r[r.__symbol__("fakeAsyncTest")];D&&"function"==typeof D.fakeAsync&&(w=D.fakeAsync(w))}return T.isTestFunc=S,v.run(w,null,arguments)};return Object.defineProperty(F,"length",{configurable:!0,writable:!0,enumerable:!1}),F.length=w.length,F}["describe","xdescribe","fdescribe"].forEach(w=>{let S=a[w];a[r.__symbol__(w)]||(a[r.__symbol__(w)]=S,a[w]=function(...F){return F[1]=N(F[1]),S.apply(this,F)},a[w].each=function E(w){return function(...S){const F=w.apply(this,S);return function(...D){return D[1]=N(D[1]),F.apply(this,D)}}}(S.each))}),a.describe.only=a.fdescribe,a.describe.skip=a.xdescribe,["it","xit","fit","test","xtest"].forEach(w=>{let S=a[w];a[r.__symbol__(w)]||(a[r.__symbol__(w)]=S,a[w]=function(...F){return F[1]=V(F[1],!0),S.apply(this,F)},a[w].each=function d(w){return function(...S){return function(...F){return F[1]=V(F[1]),w.apply(this,S).apply(this,F)}}}(S.each),a[w].todo=S.todo)}),a.it.only=a.fit,a.it.skip=a.xit,a.test.only=a.fit,a.test.skip=a.xit,["beforeEach","afterEach","beforeAll","afterAll"].forEach(w=>{let S=a[w];a[r.__symbol__(w)]||(a[r.__symbol__(w)]=S,a[w]=function(...F){return F[0]=V(F[0]),S.apply(this,F)})}),r.patchJestObject=function(S,F=!1){function D(){return!!r.current.get("FakeAsyncTestZoneSpec")}function A(){const k=r.current.get("ProxyZoneSpec");return k&&k.isTestFunc}S[g.symbol("fakeTimers")]||(S[g.symbol("fakeTimers")]=!0,g.patchMethod(S,"_checkFakeTimers",k=>function(O,G){return!!D()||k.apply(O,G)}),g.patchMethod(S,"useFakeTimers",k=>function(O,G){return r[g.symbol("useFakeTimersCalled")]=!0,F||A()?k.apply(O,G):O}),g.patchMethod(S,"useRealTimers",k=>function(O,G){return r[g.symbol("useFakeTimersCalled")]=!1,F||A()?k.apply(O,G):O}),g.patchMethod(S,"setSystemTime",k=>function(O,G){const L=r.current.get("FakeAsyncTestZoneSpec");if(!L||!D())return k.apply(O,G);L.setFakeBaseSystemTime(G[0])}),g.patchMethod(S,"getRealSystemTime",k=>function(O,G){const L=r.current.get("FakeAsyncTestZoneSpec");return L&&D()?L.getRealSystemTime():k.apply(O,G)}),g.patchMethod(S,"runAllTicks",k=>function(O,G){const L=r.current.get("FakeAsyncTestZoneSpec");if(!L)return k.apply(O,G);L.flushMicrotasks()}),g.patchMethod(S,"runAllTimers",k=>function(O,G){const L=r.current.get("FakeAsyncTestZoneSpec");if(!L)return k.apply(O,G);L.flush(100,!0)}),g.patchMethod(S,"advanceTimersByTime",k=>function(O,G){const L=r.current.get("FakeAsyncTestZoneSpec");if(!L)return k.apply(O,G);L.tick(G[0])}),g.patchMethod(S,"runOnlyPendingTimers",k=>function(O,G){const L=r.current.get("FakeAsyncTestZoneSpec");if(!L)return k.apply(O,G);L.flushOnlyPendingTimers()}),g.patchMethod(S,"advanceTimersToNextTimer",k=>function(O,G){const L=r.current.get("FakeAsyncTestZoneSpec");if(!L)return k.apply(O,G);L.tickToNext(G[0])}),g.patchMethod(S,"clearAllTimers",k=>function(O,G){const L=r.current.get("FakeAsyncTestZoneSpec");if(!L)return k.apply(O,G);L.removeAllTimers()}),g.patchMethod(S,"getTimerCount",k=>function(O,G){const L=r.current.get("FakeAsyncTestZoneSpec");return L?L.getTimerCount():k.apply(O,G)}))}}),Zone.__load_patch("mocha",(a,r)=>{const g=a.Mocha;if(typeof g>"u")return;if(typeof r>"u")throw new Error("Missing Zone.js");const l=r.ProxyZoneSpec,m=r.SyncTestZoneSpec;if(!l)throw new Error("Missing ProxyZoneSpec");if(g.__zone_patch__)throw new Error('"Mocha" has already been patched with "Zone".');g.__zone_patch__=!0;const y=r.current,I=y.fork(new m("Mocha.describe"));let T=null;const v=y.fork(new l),E={after:a.after,afterEach:a.afterEach,before:a.before,beforeEach:a.beforeEach,describe:a.describe,it:a.it};function d(S,F,D){for(let A=0;A<S.length;A++){let k=S[A];"function"==typeof k&&(S[A]=0===k.length?F(k):D(k),S[A].toString=function(){return k.toString()})}return S}function N(S){return d(S,function(D){return function(){return I.run(D,this,arguments)}})}function V(S){return d(S,function(A){return function(){return T.run(A,this)}},function(A){return function(k){return T.run(A,this,[k])}})}function w(S){return d(S,function(A){return function(){return v.run(A,this)}},function(A){return function(k){return v.run(A,this,[k])}})}var S,F;a.describe=a.suite=function(){return E.describe.apply(this,N(arguments))},a.xdescribe=a.suite.skip=a.describe.skip=function(){return E.describe.skip.apply(this,N(arguments))},a.describe.only=a.suite.only=function(){return E.describe.only.apply(this,N(arguments))},a.it=a.specify=a.test=function(){return E.it.apply(this,V(arguments))},a.xit=a.xspecify=a.it.skip=function(){return E.it.skip.apply(this,V(arguments))},a.it.only=a.test.only=function(){return E.it.only.apply(this,V(arguments))},a.after=a.suiteTeardown=function(){return E.after.apply(this,w(arguments))},a.afterEach=a.teardown=function(){return E.afterEach.apply(this,V(arguments))},a.before=a.suiteSetup=function(){return E.before.apply(this,w(arguments))},a.beforeEach=a.setup=function(){return E.beforeEach.apply(this,V(arguments))},S=g.Runner.prototype.runTest,F=g.Runner.prototype.run,g.Runner.prototype.runTest=function(D){r.current.scheduleMicroTask("mocha.forceTask",()=>{S.call(this,D)})},g.Runner.prototype.run=function(D){return this.on("test",A=>{T=y.fork(new l)}),this.on("fail",(A,k)=>{const O=T&&T.get("ProxyZoneSpec");if(O&&k)try{k.message+=O.getAndClearPendingTasksInfo()}catch{}}),F.call(this,D)}}),function(a){class r{static#e=this.symbolParentUnresolved=Zone.__symbol__("parentUnresolved");constructor(l,m,y){this.finishCallback=l,this.failCallback=m,this._pendingMicroTasks=!1,this._pendingMacroTasks=!1,this._alreadyErrored=!1,this._isSync=!1,this._existingFinishTimer=null,this.entryFunction=null,this.runZone=Zone.current,this.unresolvedChainedPromiseCount=0,this.supportWaitUnresolvedChainedPromise=!1,this.name="asyncTestZone for "+y,this.properties={AsyncTestZoneSpec:this},this.supportWaitUnresolvedChainedPromise=!0===a[Zone.__symbol__("supportWaitUnResolvedChainedPromise")]}isUnresolvedChainedPromisePending(){return this.unresolvedChainedPromiseCount>0}_finishCallbackIfDone(){null!==this._existingFinishTimer&&(clearTimeout(this._existingFinishTimer),this._existingFinishTimer=null),this._pendingMicroTasks||this._pendingMacroTasks||this.supportWaitUnresolvedChainedPromise&&this.isUnresolvedChainedPromisePending()||this.runZone.run(()=>{this._existingFinishTimer=setTimeout(()=>{!this._alreadyErrored&&!this._pendingMicroTasks&&!this._pendingMacroTasks&&this.finishCallback()},0)})}patchPromiseForTest(){if(!this.supportWaitUnresolvedChainedPromise)return;const l=Promise[Zone.__symbol__("patchPromiseForTest")];l&&l()}unPatchPromiseForTest(){if(!this.supportWaitUnresolvedChainedPromise)return;const l=Promise[Zone.__symbol__("unPatchPromiseForTest")];l&&l()}onScheduleTask(l,m,y,I){return"eventTask"!==I.type&&(this._isSync=!1),"microTask"===I.type&&I.data&&I.data instanceof Promise&&!0===I.data[r.symbolParentUnresolved]&&this.unresolvedChainedPromiseCount--,l.scheduleTask(y,I)}onInvokeTask(l,m,y,I,T,v){return"eventTask"!==I.type&&(this._isSync=!1),l.invokeTask(y,I,T,v)}onCancelTask(l,m,y,I){return"eventTask"!==I.type&&(this._isSync=!1),l.cancelTask(y,I)}onInvoke(l,m,y,I,T,v,E){this.entryFunction||(this.entryFunction=I);try{return this._isSync=!0,l.invoke(y,I,T,v,E)}finally{this._isSync&&this.entryFunction===I&&this._finishCallbackIfDone()}}onHandleError(l,m,y,I){return l.handleError(y,I)&&(this.failCallback(I),this._alreadyErrored=!0),!1}onHasTask(l,m,y,I){l.hasTask(y,I),m===y&&("microTask"==I.change?(this._pendingMicroTasks=I.microTask,this._finishCallbackIfDone()):"macroTask"==I.change&&(this._pendingMacroTasks=I.macroTask,this._finishCallbackIfDone()))}}Zone.AsyncTestZoneSpec=r}(typeof window<"u"&&window||typeof self<"u"&&self||global),Zone.__load_patch("asynctest",(a,r,g)=>{function l(m,y,I,T){const v=r.current,E=r.AsyncTestZoneSpec;if(void 0===E)throw new Error("AsyncTestZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/async-test");const d=r.ProxyZoneSpec;if(!d)throw new Error("ProxyZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/proxy");const N=d.get();d.assertPresent();const V=r.current.getZoneWith("ProxyZoneSpec"),w=N.getDelegate();return V.parent.run(()=>{const S=new E(()=>{N.getDelegate()==S&&N.setDelegate(w),S.unPatchPromiseForTest(),v.run(()=>{I()})},F=>{N.getDelegate()==S&&N.setDelegate(w),S.unPatchPromiseForTest(),v.run(()=>{T(F)})},"test");N.setDelegate(S),S.patchPromiseForTest()}),r.current.runGuarded(m,y)}r[g.symbol("asyncTest")]=function(y){return a.jasmine?function(I){I||((I=function(){}).fail=function(T){throw T}),l(y,this,I,T=>{if("string"==typeof T)return I.fail(new Error(T));I.fail(T)})}:function(){return new Promise((I,T)=>{l(y,this,I,T)})}}}),function(a){const r=a.Date;function g(){if(0===arguments.length){const I=new r;return I.setTime(g.now()),I}{const I=Array.prototype.slice.call(arguments);return new r(...I)}}g.now=function(){const I=Zone.current.get("FakeAsyncTestZoneSpec");return I?I.getFakeSystemTime():r.now.apply(this,arguments)},g.UTC=r.UTC,g.parse=r.parse;const l={setTimeout:a.setTimeout,setInterval:a.setInterval,clearTimeout:a.clearTimeout,clearInterval:a.clearInterval};let m=(()=>{class I{static#e=this.nextId=1;constructor(){this._schedulerQueue=[],this._currentTickTime=0,this._currentFakeBaseSystemTime=r.now(),this._currentTickRequeuePeriodicEntries=[]}getCurrentTickTime(){return this._currentTickTime}getFakeSystemTime(){return this._currentFakeBaseSystemTime+this._currentTickTime}setFakeBaseSystemTime(v){this._currentFakeBaseSystemTime=v}getRealSystemTime(){return r.now()}scheduleFunction(v,E,d){let N=(d={args:[],isPeriodic:!1,isRequestAnimationFrame:!1,id:-1,isRequeuePeriodic:!1,...d}).id<0?I.nextId++:d.id,w={endTime:this._currentTickTime+E,id:N,func:v,args:d.args,delay:E,isPeriodic:d.isPeriodic,isRequestAnimationFrame:d.isRequestAnimationFrame};d.isRequeuePeriodic&&this._currentTickRequeuePeriodicEntries.push(w);let S=0;for(;S<this._schedulerQueue.length&&!(w.endTime<this._schedulerQueue[S].endTime);S++);return this._schedulerQueue.splice(S,0,w),N}removeScheduledFunctionWithId(v){for(let E=0;E<this._schedulerQueue.length;E++)if(this._schedulerQueue[E].id==v){this._schedulerQueue.splice(E,1);break}}removeAll(){this._schedulerQueue=[]}getTimerCount(){return this._schedulerQueue.length}tickToNext(v=1,E,d){this._schedulerQueue.length<v||this.tick(this._schedulerQueue[v-1].endTime-this._currentTickTime,E,d)}tick(v=0,E,d){let N=this._currentTickTime+v,V=0;const w=(d=Object.assign({processNewMacroTasksSynchronously:!0},d)).processNewMacroTasksSynchronously?this._schedulerQueue:this._schedulerQueue.slice();if(0===w.length&&E)E(v);else{for(;w.length>0&&(this._currentTickRequeuePeriodicEntries=[],!(N<w[0].endTime));){let F=w.shift();if(!d.processNewMacroTasksSynchronously){const A=this._schedulerQueue.indexOf(F);A>=0&&this._schedulerQueue.splice(A,1)}if(V=this._currentTickTime,this._currentTickTime=F.endTime,E&&E(this._currentTickTime-V),!F.func.apply(a,F.isRequestAnimationFrame?[this._currentTickTime]:F.args))break;d.processNewMacroTasksSynchronously||this._currentTickRequeuePeriodicEntries.forEach(A=>{let k=0;for(;k<w.length&&!(A.endTime<w[k].endTime);k++);w.splice(k,0,A)})}V=this._currentTickTime,this._currentTickTime=N,E&&E(this._currentTickTime-V)}}flushOnlyPendingTimers(v){if(0===this._schedulerQueue.length)return 0;const E=this._currentTickTime;return this.tick(this._schedulerQueue[this._schedulerQueue.length-1].endTime-E,v,{processNewMacroTasksSynchronously:!1}),this._currentTickTime-E}flush(v=20,E=!1,d){return E?this.flushPeriodic(d):this.flushNonPeriodic(v,d)}flushPeriodic(v){if(0===this._schedulerQueue.length)return 0;const E=this._currentTickTime;return this.tick(this._schedulerQueue[this._schedulerQueue.length-1].endTime-E,v),this._currentTickTime-E}flushNonPeriodic(v,E){const d=this._currentTickTime;let N=0,V=0;for(;this._schedulerQueue.length>0;){if(V++,V>v)throw new Error("flush failed after reaching the limit of "+v+" tasks. Does your code use a polling timeout?");if(0===this._schedulerQueue.filter(F=>!F.isPeriodic&&!F.isRequestAnimationFrame).length)break;const w=this._schedulerQueue.shift();if(N=this._currentTickTime,this._currentTickTime=w.endTime,E&&E(this._currentTickTime-N),!w.func.apply(a,w.args))break}return this._currentTickTime-d}}return I})();class y{static assertInZone(){if(null==Zone.current.get("FakeAsyncTestZoneSpec"))throw new Error("The code should be running in the fakeAsync zone to call this function")}constructor(T,v=!1,E){this.trackPendingRequestAnimationFrame=v,this.macroTaskOptions=E,this._scheduler=new m,this._microtasks=[],this._lastError=null,this._uncaughtPromiseErrors=Promise[Zone.__symbol__("uncaughtPromiseErrors")],this.pendingPeriodicTimers=[],this.pendingTimers=[],this.patchDateLocked=!1,this.properties={FakeAsyncTestZoneSpec:this},this.name="fakeAsyncTestZone for "+T,this.macroTaskOptions||(this.macroTaskOptions=a[Zone.__symbol__("FakeAsyncTestMacroTask")])}_fnAndFlush(T,v){return(...E)=>(T.apply(a,E),null===this._lastError?(null!=v.onSuccess&&v.onSuccess.apply(a),this.flushMicrotasks()):null!=v.onError&&v.onError.apply(a),null===this._lastError)}static _removeTimer(T,v){let E=T.indexOf(v);E>-1&&T.splice(E,1)}_dequeueTimer(T){return()=>{y._removeTimer(this.pendingTimers,T)}}_requeuePeriodicTimer(T,v,E,d){return()=>{-1!==this.pendingPeriodicTimers.indexOf(d)&&this._scheduler.scheduleFunction(T,v,{args:E,isPeriodic:!0,id:d,isRequeuePeriodic:!0})}}_dequeuePeriodicTimer(T){return()=>{y._removeTimer(this.pendingPeriodicTimers,T)}}_setTimeout(T,v,E,d=!0){let N=this._dequeueTimer(m.nextId),V=this._fnAndFlush(T,{onSuccess:N,onError:N}),w=this._scheduler.scheduleFunction(V,v,{args:E,isRequestAnimationFrame:!d});return d&&this.pendingTimers.push(w),w}_clearTimeout(T){y._removeTimer(this.pendingTimers,T),this._scheduler.removeScheduledFunctionWithId(T)}_setInterval(T,v,E){let d=m.nextId,N={onSuccess:null,onError:this._dequeuePeriodicTimer(d)},V=this._fnAndFlush(T,N);return N.onSuccess=this._requeuePeriodicTimer(V,v,E,d),this._scheduler.scheduleFunction(V,v,{args:E,isPeriodic:!0}),this.pendingPeriodicTimers.push(d),d}_clearInterval(T){y._removeTimer(this.pendingPeriodicTimers,T),this._scheduler.removeScheduledFunctionWithId(T)}_resetLastErrorAndThrow(){let T=this._lastError||this._uncaughtPromiseErrors[0];throw this._uncaughtPromiseErrors.length=0,this._lastError=null,T}getCurrentTickTime(){return this._scheduler.getCurrentTickTime()}getFakeSystemTime(){return this._scheduler.getFakeSystemTime()}setFakeBaseSystemTime(T){this._scheduler.setFakeBaseSystemTime(T)}getRealSystemTime(){return this._scheduler.getRealSystemTime()}static patchDate(){a[Zone.__symbol__("disableDatePatching")]||a.Date!==g&&(a.Date=g,g.prototype=r.prototype,y.checkTimerPatch())}static resetDate(){a.Date===g&&(a.Date=r)}static checkTimerPatch(){a.setTimeout!==l.setTimeout&&(a.setTimeout=l.setTimeout,a.clearTimeout=l.clearTimeout),a.setInterval!==l.setInterval&&(a.setInterval=l.setInterval,a.clearInterval=l.clearInterval)}lockDatePatch(){this.patchDateLocked=!0,y.patchDate()}unlockDatePatch(){this.patchDateLocked=!1,y.resetDate()}tickToNext(T=1,v,E={processNewMacroTasksSynchronously:!0}){T<=0||(y.assertInZone(),this.flushMicrotasks(),this._scheduler.tickToNext(T,v,E),null!==this._lastError&&this._resetLastErrorAndThrow())}tick(T=0,v,E={processNewMacroTasksSynchronously:!0}){y.assertInZone(),this.flushMicrotasks(),this._scheduler.tick(T,v,E),null!==this._lastError&&this._resetLastErrorAndThrow()}flushMicrotasks(){for(y.assertInZone();this._microtasks.length>0;){let v=this._microtasks.shift();v.func.apply(v.target,v.args)}(()=>{(null!==this._lastError||this._uncaughtPromiseErrors.length)&&this._resetLastErrorAndThrow()})()}flush(T,v,E){y.assertInZone(),this.flushMicrotasks();const d=this._scheduler.flush(T,v,E);return null!==this._lastError&&this._resetLastErrorAndThrow(),d}flushOnlyPendingTimers(T){y.assertInZone(),this.flushMicrotasks();const v=this._scheduler.flushOnlyPendingTimers(T);return null!==this._lastError&&this._resetLastErrorAndThrow(),v}removeAllTimers(){y.assertInZone(),this._scheduler.removeAll(),this.pendingPeriodicTimers=[],this.pendingTimers=[]}getTimerCount(){return this._scheduler.getTimerCount()+this._microtasks.length}onScheduleTask(T,v,E,d){switch(d.type){case"microTask":let V,N=d.data&&d.data.args;if(N){let w=d.data.cbIdx;"number"==typeof N.length&&N.length>w+1&&(V=Array.prototype.slice.call(N,w+1))}this._microtasks.push({func:d.invoke,args:V,target:d.data&&d.data.target});break;case"macroTask":switch(d.source){case"setTimeout":d.data.handleId=this._setTimeout(d.invoke,d.data.delay,Array.prototype.slice.call(d.data.args,2));break;case"setImmediate":d.data.handleId=this._setTimeout(d.invoke,0,Array.prototype.slice.call(d.data.args,1));break;case"setInterval":d.data.handleId=this._setInterval(d.invoke,d.data.delay,Array.prototype.slice.call(d.data.args,2));break;case"XMLHttpRequest.send":throw new Error("Cannot make XHRs from within a fake async test. Request URL: "+d.data.url);case"requestAnimationFrame":case"webkitRequestAnimationFrame":case"mozRequestAnimationFrame":d.data.handleId=this._setTimeout(d.invoke,16,d.data.args,this.trackPendingRequestAnimationFrame);break;default:const w=this.findMacroTaskOption(d);if(w){const S=d.data&&d.data.args,F=S&&S.length>1?S[1]:0;let D=w.callbackArgs?w.callbackArgs:S;w.isPeriodic?(d.data.handleId=this._setInterval(d.invoke,F,D),d.data.isPeriodic=!0):d.data.handleId=this._setTimeout(d.invoke,F,D);break}throw new Error("Unknown macroTask scheduled in fake async test: "+d.source)}break;case"eventTask":d=T.scheduleTask(E,d)}return d}onCancelTask(T,v,E,d){switch(d.source){case"setTimeout":case"requestAnimationFrame":case"webkitRequestAnimationFrame":case"mozRequestAnimationFrame":return this._clearTimeout(d.data.handleId);case"setInterval":return this._clearInterval(d.data.handleId);default:const N=this.findMacroTaskOption(d);if(N){const V=d.data.handleId;return N.isPeriodic?this._clearInterval(V):this._clearTimeout(V)}return T.cancelTask(E,d)}}onInvoke(T,v,E,d,N,V,w){try{return y.patchDate(),T.invoke(E,d,N,V,w)}finally{this.patchDateLocked||y.resetDate()}}findMacroTaskOption(T){if(!this.macroTaskOptions)return null;for(let v=0;v<this.macroTaskOptions.length;v++){const E=this.macroTaskOptions[v];if(E.source===T.source)return E}return null}onHandleError(T,v,E,d){return this._lastError=d,!1}}Zone.FakeAsyncTestZoneSpec=y}("object"==typeof window&&window||"object"==typeof self&&self||global),Zone.__load_patch("fakeasync",(a,r,g)=>{const l=r&&r.FakeAsyncTestZoneSpec;function m(){return r&&r.ProxyZoneSpec}let y=null;function I(){y&&y.unlockDatePatch(),y=null,m()&&m().assertPresent().resetDelegate()}function v(){if(null==y&&(y=r.current.get("FakeAsyncTestZoneSpec"),null==y))throw new Error("The code should be running in the fakeAsync zone to call this function");return y}function V(){v().flushMicrotasks()}r[g.symbol("fakeAsyncTest")]={resetFakeAsyncZone:I,flushMicrotasks:V,discardPeriodicTasks:function N(){v().pendingPeriodicTimers.length=0},tick:function E(w=0,S=!1){v().tick(w,null,S)},flush:function d(w){return v().flush(w)},fakeAsync:function T(w){const S=function(...F){const D=m();if(!D)throw new Error("ProxyZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/proxy");const A=D.assertPresent();if(r.current.get("FakeAsyncTestZoneSpec"))throw new Error("fakeAsync() calls can not be nested");try{if(!y){if(A.getDelegate()instanceof l)throw new Error("fakeAsync() calls can not be nested");y=new l}let k;const O=A.getDelegate();A.setDelegate(y),y.lockDatePatch();try{k=w.apply(this,F),V()}finally{A.setDelegate(O)}if(y.pendingPeriodicTimers.length>0)throw new Error(`${y.pendingPeriodicTimers.length} periodic timer(s) still in the queue.`);if(y.pendingTimers.length>0)throw new Error(`${y.pendingTimers.length} timer(s) still in the queue.`);return k}finally{I()}};return S.isFakeAsync=!0,S}}},!0),Zone.__load_patch("promisefortest",(a,r,g)=>{const l=g.symbol("state"),y=g.symbol("parentUnresolved");Promise[g.symbol("patchPromiseForTest")]=function(){let T=Promise[r.__symbol__("ZonePromiseThen")];T||(T=Promise[r.__symbol__("ZonePromiseThen")]=Promise.prototype.then,Promise.prototype.then=function(){const v=T.apply(this,arguments);if(null===this[l]){const E=r.current.get("AsyncTestZoneSpec");E&&(E.unresolvedChainedPromiseCount++,v[y]=!0)}return v})},Promise[g.symbol("unPatchPromiseForTest")]=function(){const T=Promise[r.__symbol__("ZonePromiseThen")];T&&(Promise.prototype.then=T,Promise[r.__symbol__("ZonePromiseThen")]=void 0)}})},332:()=>{!function(e){const n=e.performance;function u(le){n&&n.mark&&n.mark(le)}function c(le,q){n&&n.measure&&n.measure(le,q)}u("Zone");const f=e.__Zone_symbol_prefix||"__zone_symbol__";function p(le){return f+le}const j=!0===e[p("forceDuplicateZoneCheck")];if(e.Zone){if(j||"function"!=typeof e.Zone.__symbol__)throw new Error("Zone already loaded.");return e.Zone}let Z=(()=>{class le{static#e=this.__symbol__=p;static assertZonePatched(){if(e.Promise!==qe.ZoneAwarePromise)throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)")}static get root(){let t=le.current;for(;t.parent;)t=t.parent;return t}static get current(){return Se.zone}static get currentTask(){return Le}static __load_patch(t,i,Y=!1){if(qe.hasOwnProperty(t)){if(!Y&&j)throw Error("Already loaded patch: "+t)}else if(!e["__Zone_disable_"+t]){const te="Zone:"+t;u(te),qe[t]=i(e,le,be),c(te,te)}}get parent(){return this._parent}get name(){return this._name}constructor(t,i){this._parent=t,this._name=i?i.name||"unnamed":"<root>",this._properties=i&&i.properties||{},this._zoneDelegate=new X(this,this._parent&&this._parent._zoneDelegate,i)}get(t){const i=this.getZoneWith(t);if(i)return i._properties[t]}getZoneWith(t){let i=this;for(;i;){if(i._properties.hasOwnProperty(t))return i;i=i._parent}return null}fork(t){if(!t)throw new Error("ZoneSpec required!");return this._zoneDelegate.fork(this,t)}wrap(t,i){if("function"!=typeof t)throw new Error("Expecting function got: "+t);const Y=this._zoneDelegate.intercept(this,t,i),te=this;return function(){return te.runGuarded(Y,this,arguments,i)}}run(t,i,Y,te){Se={parent:Se,zone:this};try{return this._zoneDelegate.invoke(this,t,i,Y,te)}finally{Se=Se.parent}}runGuarded(t,i=null,Y,te){Se={parent:Se,zone:this};try{try{return this._zoneDelegate.invoke(this,t,i,Y,te)}catch(Ie){if(this._zoneDelegate.handleError(this,Ie))throw Ie}}finally{Se=Se.parent}}runTask(t,i,Y){if(t.zone!=this)throw new Error("A task can only be run in the zone of creation! (Creation: "+(t.zone||Ae).name+"; Execution: "+this.name+")");if(t.state===de&&(t.type===Ze||t.type===K))return;const te=t.state!=$;te&&t._transitionTo($,he),t.runCount++;const Ie=Le;Le=t,Se={parent:Se,zone:this};try{t.type==K&&t.data&&!t.data.isPeriodic&&(t.cancelFn=void 0);try{return this._zoneDelegate.invokeTask(this,t,i,Y)}catch(b){if(this._zoneDelegate.handleError(this,b))throw b}}finally{t.state!==de&&t.state!==M&&(t.type==Ze||t.data&&t.data.isPeriodic?te&&t._transitionTo(he,$):(t.runCount=0,this._updateTaskCount(t,-1),te&&t._transitionTo(de,$,de))),Se=Se.parent,Le=Ie}}scheduleTask(t){if(t.zone&&t.zone!==this){let Y=this;for(;Y;){if(Y===t.zone)throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${t.zone.name}`);Y=Y.parent}}t._transitionTo(we,de);const i=[];t._zoneDelegates=i,t._zone=this;try{t=this._zoneDelegate.scheduleTask(this,t)}catch(Y){throw t._transitionTo(M,we,de),this._zoneDelegate.handleError(this,Y),Y}return t._zoneDelegates===i&&this._updateTaskCount(t,1),t.state==we&&t._transitionTo(he,we),t}scheduleMicroTask(t,i,Y,te){return this.scheduleTask(new z(ae,t,i,Y,te,void 0))}scheduleMacroTask(t,i,Y,te,Ie){return this.scheduleTask(new z(K,t,i,Y,te,Ie))}scheduleEventTask(t,i,Y,te,Ie){return this.scheduleTask(new z(Ze,t,i,Y,te,Ie))}cancelTask(t){if(t.zone!=this)throw new Error("A task can only be cancelled in the zone of creation! (Creation: "+(t.zone||Ae).name+"; Execution: "+this.name+")");if(t.state===he||t.state===$){t._transitionTo(me,he,$);try{this._zoneDelegate.cancelTask(this,t)}catch(i){throw t._transitionTo(M,me),this._zoneDelegate.handleError(this,i),i}return this._updateTaskCount(t,-1),t._transitionTo(de,me),t.runCount=0,t}}_updateTaskCount(t,i){const Y=t._zoneDelegates;-1==i&&(t._zoneDelegates=null);for(let te=0;te<Y.length;te++)Y[te]._updateTaskCount(t.type,i)}}return le})();const Q={name:"",onHasTask:(le,q,t,i)=>le.hasTask(t,i),onScheduleTask:(le,q,t,i)=>le.scheduleTask(t,i),onInvokeTask:(le,q,t,i,Y,te)=>le.invokeTask(t,i,Y,te),onCancelTask:(le,q,t,i)=>le.cancelTask(t,i)};class X{constructor(q,t,i){this._taskCounts={microTask:0,macroTask:0,eventTask:0},this.zone=q,this._parentDelegate=t,this._forkZS=i&&(i&&i.onFork?i:t._forkZS),this._forkDlgt=i&&(i.onFork?t:t._forkDlgt),this._forkCurrZone=i&&(i.onFork?this.zone:t._forkCurrZone),this._interceptZS=i&&(i.onIntercept?i:t._interceptZS),this._interceptDlgt=i&&(i.onIntercept?t:t._interceptDlgt),this._interceptCurrZone=i&&(i.onIntercept?this.zone:t._interceptCurrZone),this._invokeZS=i&&(i.onInvoke?i:t._invokeZS),this._invokeDlgt=i&&(i.onInvoke?t:t._invokeDlgt),this._invokeCurrZone=i&&(i.onInvoke?this.zone:t._invokeCurrZone),this._handleErrorZS=i&&(i.onHandleError?i:t._handleErrorZS),this._handleErrorDlgt=i&&(i.onHandleError?t:t._handleErrorDlgt),this._handleErrorCurrZone=i&&(i.onHandleError?this.zone:t._handleErrorCurrZone),this._scheduleTaskZS=i&&(i.onScheduleTask?i:t._scheduleTaskZS),this._scheduleTaskDlgt=i&&(i.onScheduleTask?t:t._scheduleTaskDlgt),this._scheduleTaskCurrZone=i&&(i.onScheduleTask?this.zone:t._scheduleTaskCurrZone),this._invokeTaskZS=i&&(i.onInvokeTask?i:t._invokeTaskZS),this._invokeTaskDlgt=i&&(i.onInvokeTask?t:t._invokeTaskDlgt),this._invokeTaskCurrZone=i&&(i.onInvokeTask?this.zone:t._invokeTaskCurrZone),this._cancelTaskZS=i&&(i.onCancelTask?i:t._cancelTaskZS),this._cancelTaskDlgt=i&&(i.onCancelTask?t:t._cancelTaskDlgt),this._cancelTaskCurrZone=i&&(i.onCancelTask?this.zone:t._cancelTaskCurrZone),this._hasTaskZS=null,this._hasTaskDlgt=null,this._hasTaskDlgtOwner=null,this._hasTaskCurrZone=null;const Y=i&&i.onHasTask;(Y||t&&t._hasTaskZS)&&(this._hasTaskZS=Y?i:Q,this._hasTaskDlgt=t,this._hasTaskDlgtOwner=this,this._hasTaskCurrZone=q,i.onScheduleTask||(this._scheduleTaskZS=Q,this._scheduleTaskDlgt=t,this._scheduleTaskCurrZone=this.zone),i.onInvokeTask||(this._invokeTaskZS=Q,this._invokeTaskDlgt=t,this._invokeTaskCurrZone=this.zone),i.onCancelTask||(this._cancelTaskZS=Q,this._cancelTaskDlgt=t,this._cancelTaskCurrZone=this.zone))}fork(q,t){return this._forkZS?this._forkZS.onFork(this._forkDlgt,this.zone,q,t):new Z(q,t)}intercept(q,t,i){return this._interceptZS?this._interceptZS.onIntercept(this._interceptDlgt,this._interceptCurrZone,q,t,i):t}invoke(q,t,i,Y,te){return this._invokeZS?this._invokeZS.onInvoke(this._invokeDlgt,this._invokeCurrZone,q,t,i,Y,te):t.apply(i,Y)}handleError(q,t){return!this._handleErrorZS||this._handleErrorZS.onHandleError(this._handleErrorDlgt,this._handleErrorCurrZone,q,t)}scheduleTask(q,t){let i=t;if(this._scheduleTaskZS)this._hasTaskZS&&i._zoneDelegates.push(this._hasTaskDlgtOwner),i=this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt,this._scheduleTaskCurrZone,q,t),i||(i=t);else if(t.scheduleFn)t.scheduleFn(t);else{if(t.type!=ae)throw new Error("Task is missing scheduleFn.");ee(t)}return i}invokeTask(q,t,i,Y){return this._invokeTaskZS?this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt,this._invokeTaskCurrZone,q,t,i,Y):t.callback.apply(i,Y)}cancelTask(q,t){let i;if(this._cancelTaskZS)i=this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt,this._cancelTaskCurrZone,q,t);else{if(!t.cancelFn)throw Error("Task is not cancelable");i=t.cancelFn(t)}return i}hasTask(q,t){try{this._hasTaskZS&&this._hasTaskZS.onHasTask(this._hasTaskDlgt,this._hasTaskCurrZone,q,t)}catch(i){this.handleError(q,i)}}_updateTaskCount(q,t){const i=this._taskCounts,Y=i[q],te=i[q]=Y+t;if(te<0)throw new Error("More tasks executed then were scheduled.");0!=Y&&0!=te||this.hasTask(this.zone,{microTask:i.microTask>0,macroTask:i.macroTask>0,eventTask:i.eventTask>0,change:q})}}class z{constructor(q,t,i,Y,te,Ie){if(this._zone=null,this.runCount=0,this._zoneDelegates=null,this._state="notScheduled",this.type=q,this.source=t,this.data=Y,this.scheduleFn=te,this.cancelFn=Ie,!i)throw new Error("callback is not defined");this.callback=i;const b=this;this.invoke=q===Ze&&Y&&Y.useG?z.invokeTask:function(){return z.invokeTask.call(e,b,this,arguments)}}static invokeTask(q,t,i){q||(q=this),De++;try{return q.runCount++,q.zone.runTask(q,t,i)}finally{1==De&&U(),De--}}get zone(){return this._zone}get state(){return this._state}cancelScheduleRequest(){this._transitionTo(de,we)}_transitionTo(q,t,i){if(this._state!==t&&this._state!==i)throw new Error(`${this.type} '${this.source}': can not transition to '${q}', expecting state '${t}'${i?" or '"+i+"'":""}, was '${this._state}'.`);this._state=q,q==de&&(this._zoneDelegates=null)}toString(){return this.data&&typeof this.data.handleId<"u"?this.data.handleId.toString():Object.prototype.toString.call(this)}toJSON(){return{type:this.type,state:this.state,source:this.source,zone:this.zone.name,runCount:this.runCount}}}const oe=p("setTimeout"),ie=p("Promise"),ce=p("then");let Re,ke=[],fe=!1;function ve(le){if(Re||e[ie]&&(Re=e[ie].resolve(0)),Re){let q=Re[ce];q||(q=Re.then),q.call(Re,le)}else e[oe](le,0)}function ee(le){0===De&&0===ke.length&&ve(U),le&&ke.push(le)}function U(){if(!fe){for(fe=!0;ke.length;){const le=ke;ke=[];for(let q=0;q<le.length;q++){const t=le[q];try{t.zone.runTask(t,null,null)}catch(i){be.onUnhandledError(i)}}}be.microtaskDrainDone(),fe=!1}}const Ae={name:"NO ZONE"},de="notScheduled",we="scheduling",he="scheduled",$="running",me="canceling",M="unknown",ae="microTask",K="macroTask",Ze="eventTask",qe={},be={symbol:p,currentZoneFrame:()=>Se,onUnhandledError:Pe,microtaskDrainDone:Pe,scheduleMicroTask:ee,showUncaughtError:()=>!Z[p("ignoreConsoleErrorUncaughtError")],patchEventTarget:()=>[],patchOnProperties:Pe,patchMethod:()=>Pe,bindArguments:()=>[],patchThen:()=>Pe,patchMacroTask:()=>Pe,patchEventPrototype:()=>Pe,isIEOrEdge:()=>!1,getGlobalObjects:()=>{},ObjectDefineProperty:()=>Pe,ObjectGetOwnPropertyDescriptor:()=>{},ObjectCreate:()=>{},ArraySlice:()=>[],patchClass:()=>Pe,wrapWithCurrentZone:()=>Pe,filterProperties:()=>[],attachOriginToPatched:()=>Pe,_redefineProperty:()=>Pe,patchCallbacks:()=>Pe,nativeScheduleMicroTask:ve};let Se={parent:null,zone:new Z(null,null)},Le=null,De=0;function Pe(){}c("Zone","Zone"),e.Zone=Z}(globalThis);const xe=Object.getOwnPropertyDescriptor,Ge=Object.defineProperty,Ne=Object.getPrototypeOf,He=Object.create,et=Array.prototype.slice,Be="addEventListener",We="removeEventListener",Oe=Zone.__symbol__(Be),tt=Zone.__symbol__(We),Me="true",je="false",Ve=Zone.__symbol__("");function Qe(e,n){return Zone.current.wrap(e,n)}function nt(e,n,u,c,f){return Zone.current.scheduleMacroTask(e,n,u,c,f)}const ue=Zone.__symbol__,Ue=typeof window<"u",Fe=Ue?window:void 0,pe=Ue&&Fe||globalThis,$e="removeAttribute";function Xe(e,n){for(let u=e.length-1;u>=0;u--)"function"==typeof e[u]&&(e[u]=Qe(e[u],n+"_"+u));return e}function r(e){return!e||!1!==e.writable&&!("function"==typeof e.get&&typeof e.set>"u")}const g=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope,l=!("nw"in pe)&&typeof pe.process<"u"&&"[object process]"==={}.toString.call(pe.process),m=!l&&!g&&!(!Ue||!Fe.HTMLElement),y=typeof pe.process<"u"&&"[object process]"==={}.toString.call(pe.process)&&!g&&!(!Ue||!Fe.HTMLElement),I={},T=function(e){if(!(e=e||pe.event))return;let n=I[e.type];n||(n=I[e.type]=ue("ON_PROPERTY"+e.type));const u=this||e.target||pe,c=u[n];let f;return m&&u===Fe&&"error"===e.type?(f=c&&c.call(this,e.message,e.filename,e.lineno,e.colno,e.error),!0===f&&e.preventDefault()):(f=c&&c.apply(this,arguments),null!=f&&!f&&e.preventDefault()),f};function v(e,n,u){let c=xe(e,n);if(!c&&u&&xe(u,n)&&(c={enumerable:!0,configurable:!0}),!c||!c.configurable)return;const f=ue("on"+n+"patched");if(e.hasOwnProperty(f)&&e[f])return;delete c.writable,delete c.value;const p=c.get,j=c.set,Z=n.slice(2);let Q=I[Z];Q||(Q=I[Z]=ue("ON_PROPERTY"+Z)),c.set=function(X){let z=this;!z&&e===pe&&(z=pe),z&&("function"==typeof z[Q]&&z.removeEventListener(Z,T),j&&j.call(z,null),z[Q]=X,"function"==typeof X&&z.addEventListener(Z,T,!1))},c.get=function(){let X=this;if(!X&&e===pe&&(X=pe),!X)return null;const z=X[Q];if(z)return z;if(p){let oe=p.call(this);if(oe)return c.set.call(this,oe),"function"==typeof X[$e]&&X.removeAttribute(n),oe}return null},Ge(e,n,c),e[f]=!0}function E(e,n,u){if(n)for(let c=0;c<n.length;c++)v(e,"on"+n[c],u);else{const c=[];for(const f in e)"on"==f.slice(0,2)&&c.push(f);for(let f=0;f<c.length;f++)v(e,c[f],u)}}const d=ue("originalInstance");function N(e){const n=pe[e];if(!n)return;pe[ue(e)]=n,pe[e]=function(){const f=Xe(arguments,e);switch(f.length){case 0:this[d]=new n;break;case 1:this[d]=new n(f[0]);break;case 2:this[d]=new n(f[0],f[1]);break;case 3:this[d]=new n(f[0],f[1],f[2]);break;case 4:this[d]=new n(f[0],f[1],f[2],f[3]);break;default:throw new Error("Arg list too long.")}},S(pe[e],n);const u=new n(function(){});let c;for(c in u)"XMLHttpRequest"===e&&"responseBlob"===c||function(f){"function"==typeof u[f]?pe[e].prototype[f]=function(){return this[d][f].apply(this[d],arguments)}:Ge(pe[e].prototype,f,{set:function(p){"function"==typeof p?(this[d][f]=Qe(p,e+"."+f),S(this[d][f],p)):this[d][f]=p},get:function(){return this[d][f]}})}(c);for(c in n)"prototype"!==c&&n.hasOwnProperty(c)&&(pe[e][c]=n[c])}function V(e,n,u){let c=e;for(;c&&!c.hasOwnProperty(n);)c=Ne(c);!c&&e[n]&&(c=e);const f=ue(n);let p=null;if(c&&(!(p=c[f])||!c.hasOwnProperty(f))&&(p=c[f]=c[n],r(c&&xe(c,n)))){const Z=u(p,f,n);c[n]=function(){return Z(this,arguments)},S(c[n],p)}return p}function w(e,n,u){let c=null;function f(p){const j=p.data;return j.args[j.cbIdx]=function(){p.invoke.apply(this,arguments)},c.apply(j.target,j.args),p}c=V(e,n,p=>function(j,Z){const Q=u(j,Z);return Q.cbIdx>=0&&"function"==typeof Z[Q.cbIdx]?nt(Q.name,Z[Q.cbIdx],Q,f):p.apply(j,Z)})}function S(e,n){e[ue("OriginalDelegate")]=n}let F=!1,D=!1;function k(){if(F)return D;F=!0;try{const e=Fe.navigator.userAgent;(-1!==e.indexOf("MSIE ")||-1!==e.indexOf("Trident/")||-1!==e.indexOf("Edge/"))&&(D=!0)}catch{}return D}Zone.__load_patch("ZoneAwarePromise",(e,n,u)=>{const c=Object.getOwnPropertyDescriptor,f=Object.defineProperty,j=u.symbol,Z=[],Q=!1!==e[j("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")],X=j("Promise"),z=j("then"),oe="__creationTrace__";u.onUnhandledError=b=>{if(u.showUncaughtError()){const C=b&&b.rejection;C?console.error("Unhandled Promise rejection:",C instanceof Error?C.message:C,"; Zone:",b.zone.name,"; Task:",b.task&&b.task.source,"; Value:",C,C instanceof Error?C.stack:void 0):console.error(b)}},u.microtaskDrainDone=()=>{for(;Z.length;){const b=Z.shift();try{b.zone.runGuarded(()=>{throw b.throwOriginal?b.rejection:b})}catch(C){ce(C)}}};const ie=j("unhandledPromiseRejectionHandler");function ce(b){u.onUnhandledError(b);try{const C=n[ie];"function"==typeof C&&C.call(this,b)}catch{}}function ke(b){return b&&b.then}function fe(b){return b}function Re(b){return t.reject(b)}const ve=j("state"),ee=j("value"),U=j("finally"),Ae=j("parentPromiseValue"),de=j("parentPromiseState"),we="Promise.then",he=null,$=!0,me=!1,M=0;function ae(b,C){return h=>{try{be(b,C,h)}catch(R){be(b,!1,R)}}}const K=function(){let b=!1;return function(h){return function(){b||(b=!0,h.apply(null,arguments))}}},Ze="Promise resolved with itself",qe=j("currentTaskTrace");function be(b,C,h){const R=K();if(b===h)throw new TypeError(Ze);if(b[ve]===he){let W=null;try{("object"==typeof h||"function"==typeof h)&&(W=h&&h.then)}catch(J){return R(()=>{be(b,!1,J)})(),b}if(C!==me&&h instanceof t&&h.hasOwnProperty(ve)&&h.hasOwnProperty(ee)&&h[ve]!==he)Le(h),be(b,h[ve],h[ee]);else if(C!==me&&"function"==typeof W)try{W.call(h,R(ae(b,C)),R(ae(b,!1)))}catch(J){R(()=>{be(b,!1,J)})()}else{b[ve]=C;const J=b[ee];if(b[ee]=h,b[U]===U&&C===$&&(b[ve]=b[de],b[ee]=b[Ae]),C===me&&h instanceof Error){const B=n.currentTask&&n.currentTask.data&&n.currentTask.data[oe];B&&f(h,qe,{configurable:!0,enumerable:!1,writable:!0,value:B})}for(let B=0;B<J.length;)De(b,J[B++],J[B++],J[B++],J[B++]);if(0==J.length&&C==me){b[ve]=M;let B=h;try{throw new Error("Uncaught (in promise): "+function p(b){return b&&b.toString===Object.prototype.toString?(b.constructor&&b.constructor.name||"")+": "+JSON.stringify(b):b?b.toString():Object.prototype.toString.call(b)}(h)+(h&&h.stack?"\n"+h.stack:""))}catch(ne){B=ne}Q&&(B.throwOriginal=!0),B.rejection=h,B.promise=b,B.zone=n.current,B.task=n.currentTask,Z.push(B),u.scheduleMicroTask()}}}return b}const Se=j("rejectionHandledHandler");function Le(b){if(b[ve]===M){try{const C=n[Se];C&&"function"==typeof C&&C.call(this,{rejection:b[ee],promise:b})}catch{}b[ve]=me;for(let C=0;C<Z.length;C++)b===Z[C].promise&&Z.splice(C,1)}}function De(b,C,h,R,W){Le(b);const J=b[ve],B=J?"function"==typeof R?R:fe:"function"==typeof W?W:Re;C.scheduleMicroTask(we,()=>{try{const ne=b[ee],re=!!h&&U===h[U];re&&(h[Ae]=ne,h[de]=J);const se=C.run(B,void 0,re&&B!==Re&&B!==fe?[]:[ne]);be(h,!0,se)}catch(ne){be(h,!1,ne)}},h)}const le=function(){},q=e.AggregateError;class t{static toString(){return"function ZoneAwarePromise() { [native code] }"}static resolve(C){return be(new this(null),$,C)}static reject(C){return be(new this(null),me,C)}static any(C){if(!C||"function"!=typeof C[Symbol.iterator])return Promise.reject(new q([],"All promises were rejected"));const h=[];let R=0;try{for(let B of C)R++,h.push(t.resolve(B))}catch{return Promise.reject(new q([],"All promises were rejected"))}if(0===R)return Promise.reject(new q([],"All promises were rejected"));let W=!1;const J=[];return new t((B,ne)=>{for(let re=0;re<h.length;re++)h[re].then(se=>{W||(W=!0,B(se))},se=>{J.push(se),R--,0===R&&(W=!0,ne(new q(J,"All promises were rejected")))})})}static race(C){let h,R,W=new this((ne,re)=>{h=ne,R=re});function J(ne){h(ne)}function B(ne){R(ne)}for(let ne of C)ke(ne)||(ne=this.resolve(ne)),ne.then(J,B);return W}static all(C){return t.allWithCallback(C)}static allSettled(C){return(this&&this.prototype instanceof t?this:t).allWithCallback(C,{thenCallback:R=>({status:"fulfilled",value:R}),errorCallback:R=>({status:"rejected",reason:R})})}static allWithCallback(C,h){let R,W,J=new this((se,ye)=>{R=se,W=ye}),B=2,ne=0;const re=[];for(let se of C){ke(se)||(se=this.resolve(se));const ye=ne;try{se.then(ge=>{re[ye]=h?h.thenCallback(ge):ge,B--,0===B&&R(re)},ge=>{h?(re[ye]=h.errorCallback(ge),B--,0===B&&R(re)):W(ge)})}catch(ge){W(ge)}B++,ne++}return B-=2,0===B&&R(re),J}constructor(C){const h=this;if(!(h instanceof t))throw new Error("Must be an instanceof Promise.");h[ve]=he,h[ee]=[];try{const R=K();C&&C(R(ae(h,$)),R(ae(h,me)))}catch(R){be(h,!1,R)}}get[Symbol.toStringTag](){return"Promise"}get[Symbol.species](){return t}then(C,h){let R=this.constructor?.[Symbol.species];(!R||"function"!=typeof R)&&(R=this.constructor||t);const W=new R(le),J=n.current;return this[ve]==he?this[ee].push(J,W,C,h):De(this,J,W,C,h),W}catch(C){return this.then(null,C)}finally(C){let h=this.constructor?.[Symbol.species];(!h||"function"!=typeof h)&&(h=t);const R=new h(le);R[U]=U;const W=n.current;return this[ve]==he?this[ee].push(W,R,C,C):De(this,W,R,C,C),R}}t.resolve=t.resolve,t.reject=t.reject,t.race=t.race,t.all=t.all;const i=e[X]=e.Promise;e.Promise=t;const Y=j("thenPatched");function te(b){const C=b.prototype,h=c(C,"then");if(h&&(!1===h.writable||!h.configurable))return;const R=C.then;C[z]=R,b.prototype.then=function(W,J){return new t((ne,re)=>{R.call(this,ne,re)}).then(W,J)},b[Y]=!0}return u.patchThen=te,i&&(te(i),V(e,"fetch",b=>function Ie(b){return function(C,h){let R=b.apply(C,h);if(R instanceof t)return R;let W=R.constructor;return W[Y]||te(W),R}}(b))),Promise[n.__symbol__("uncaughtPromiseErrors")]=Z,t}),Zone.__load_patch("toString",e=>{const n=Function.prototype.toString,u=ue("OriginalDelegate"),c=ue("Promise"),f=ue("Error"),p=function(){if("function"==typeof this){const X=this[u];if(X)return"function"==typeof X?n.call(X):Object.prototype.toString.call(X);if(this===Promise){const z=e[c];if(z)return n.call(z)}if(this===Error){const z=e[f];if(z)return n.call(z)}}return n.call(this)};p[u]=n,Function.prototype.toString=p;const j=Object.prototype.toString;Object.prototype.toString=function(){return"function"==typeof Promise&&this instanceof Promise?"[object Promise]":j.call(this)}});let O=!1;if(typeof window<"u")try{const e=Object.defineProperty({},"passive",{get:function(){O=!0}});window.addEventListener("test",e,e),window.removeEventListener("test",e,e)}catch{O=!1}const G={useG:!0},L={},Ee={},Ye=new RegExp("^"+Ve+"(\\w+)(true|false)$"),it=ue("propagationStopped");function ot(e,n){const u=(n?n(e):e)+je,c=(n?n(e):e)+Me,f=Ve+u,p=Ve+c;L[e]={},L[e][je]=f,L[e][Me]=p}function ct(e,n,u,c){const f=c&&c.add||Be,p=c&&c.rm||We,j=c&&c.listeners||"eventListeners",Z=c&&c.rmAll||"removeAllListeners",Q=ue(f),X="."+f+":",z="prependListener",oe="."+z+":",ie=function(ee,U,Ae){if(ee.isRemoved)return;const de=ee.callback;let we;"object"==typeof de&&de.handleEvent&&(ee.callback=$=>de.handleEvent($),ee.originalDelegate=de);try{ee.invoke(ee,U,[Ae])}catch($){we=$}const he=ee.options;return he&&"object"==typeof he&&he.once&&U[p].call(U,Ae.type,ee.originalDelegate?ee.originalDelegate:ee.callback,he),we};function ce(ee,U,Ae){if(!(U=U||e.event))return;const de=ee||U.target||e,we=de[L[U.type][Ae?Me:je]];if(we){const he=[];if(1===we.length){const $=ie(we[0],de,U);$&&he.push($)}else{const $=we.slice();for(let me=0;me<$.length&&(!U||!0!==U[it]);me++){const M=ie($[me],de,U);M&&he.push(M)}}if(1===he.length)throw he[0];for(let $=0;$<he.length;$++){const me=he[$];n.nativeScheduleMicroTask(()=>{throw me})}}}const ke=function(ee){return ce(this,ee,!1)},fe=function(ee){return ce(this,ee,!0)};function Re(ee,U){if(!ee)return!1;let Ae=!0;U&&void 0!==U.useG&&(Ae=U.useG);const de=U&&U.vh;let we=!0;U&&void 0!==U.chkDup&&(we=U.chkDup);let he=!1;U&&void 0!==U.rt&&(he=U.rt);let $=ee;for(;$&&!$.hasOwnProperty(f);)$=Ne($);if(!$&&ee[f]&&($=ee),!$||$[Q])return!1;const me=U&&U.eventNameToString,M={},ae=$[Q]=$[f],K=$[ue(p)]=$[p],Ze=$[ue(j)]=$[j],qe=$[ue(Z)]=$[Z];let be;U&&U.prepend&&(be=$[ue(U.prepend)]=$[U.prepend]);const t=Ae?function(h){if(!M.isExisting)return ae.call(M.target,M.eventName,M.capture?fe:ke,M.options)}:function(h){return ae.call(M.target,M.eventName,h.invoke,M.options)},i=Ae?function(h){if(!h.isRemoved){const R=L[h.eventName];let W;R&&(W=R[h.capture?Me:je]);const J=W&&h.target[W];if(J)for(let B=0;B<J.length;B++)if(J[B]===h){J.splice(B,1),h.isRemoved=!0,0===J.length&&(h.allRemoved=!0,h.target[W]=null);break}}if(h.allRemoved)return K.call(h.target,h.eventName,h.capture?fe:ke,h.options)}:function(h){return K.call(h.target,h.eventName,h.invoke,h.options)},te=U&&U.diff?U.diff:function(h,R){const W=typeof R;return"function"===W&&h.callback===R||"object"===W&&h.originalDelegate===R},Ie=Zone[ue("UNPATCHED_EVENTS")],b=e[ue("PASSIVE_EVENTS")],C=function(h,R,W,J,B=!1,ne=!1){return function(){const re=this||e;let se=arguments[0];U&&U.transferEventName&&(se=U.transferEventName(se));let ye=arguments[1];if(!ye)return h.apply(this,arguments);if(l&&"uncaughtException"===se)return h.apply(this,arguments);let ge=!1;if("function"!=typeof ye){if(!ye.handleEvent)return h.apply(this,arguments);ge=!0}if(de&&!de(h,ye,re,arguments))return;const Ke=O&&!!b&&-1!==b.indexOf(se),ze=function Se(h,R){return!O&&"object"==typeof h&&h?!!h.capture:O&&R?"boolean"==typeof h?{capture:h,passive:!0}:h?"object"==typeof h&&!1!==h.passive?{...h,passive:!0}:h:{passive:!0}:h}(arguments[2],Ke);if(Ie)for(let rt=0;rt<Ie.length;rt++)if(se===Ie[rt])return Ke?h.call(re,se,ye,ze):h.apply(this,arguments);const dt=!!ze&&("boolean"==typeof ze||ze.capture),_t=!(!ze||"object"!=typeof ze)&&ze.once,Et=Zone.current;let Tt=L[se];Tt||(ot(se,me),Tt=L[se]);const mt=Tt[dt?Me:je];let ht,st=re[mt],yt=!1;if(st){if(yt=!0,we)for(let rt=0;rt<st.length;rt++)if(te(st[rt],ye))return}else st=re[mt]=[];const gt=re.constructor.name,kt=Ee[gt];kt&&(ht=kt[se]),ht||(ht=gt+R+(me?me(se):se)),M.options=ze,_t&&(M.options.once=!1),M.target=re,M.capture=dt,M.eventName=se,M.isExisting=yt;const at=Ae?G:void 0;at&&(at.taskData=M);const Je=Et.scheduleEventTask(ht,ye,at,W,J);return M.target=null,at&&(at.taskData=null),_t&&(ze.once=!0),!O&&"boolean"==typeof Je.options||(Je.options=ze),Je.target=re,Je.capture=dt,Je.eventName=se,ge&&(Je.originalDelegate=ye),ne?st.unshift(Je):st.push(Je),B?re:void 0}};return $[f]=C(ae,X,t,i,he),be&&($[z]=C(be,oe,function(h){return be.call(M.target,M.eventName,h.invoke,M.options)},i,he,!0)),$[p]=function(){const h=this||e;let R=arguments[0];U&&U.transferEventName&&(R=U.transferEventName(R));const W=arguments[2],J=!!W&&("boolean"==typeof W||W.capture),B=arguments[1];if(!B)return K.apply(this,arguments);if(de&&!de(K,B,h,arguments))return;const ne=L[R];let re;ne&&(re=ne[J?Me:je]);const se=re&&h[re];if(se)for(let ye=0;ye<se.length;ye++){const ge=se[ye];if(te(ge,B))return se.splice(ye,1),ge.isRemoved=!0,0===se.length&&(ge.allRemoved=!0,h[re]=null,"string"==typeof R)&&(h[Ve+"ON_PROPERTY"+R]=null),ge.zone.cancelTask(ge),he?h:void 0}return K.apply(this,arguments)},$[j]=function(){const h=this||e;let R=arguments[0];U&&U.transferEventName&&(R=U.transferEventName(R));const W=[],J=ut(h,me?me(R):R);for(let B=0;B<J.length;B++){const ne=J[B];W.push(ne.originalDelegate?ne.originalDelegate:ne.callback)}return W},$[Z]=function(){const h=this||e;let R=arguments[0];if(R){U&&U.transferEventName&&(R=U.transferEventName(R));const W=L[R];if(W){const ne=h[W[je]],re=h[W[Me]];if(ne){const se=ne.slice();for(let ye=0;ye<se.length;ye++){const ge=se[ye];this[p].call(this,R,ge.originalDelegate?ge.originalDelegate:ge.callback,ge.options)}}if(re){const se=re.slice();for(let ye=0;ye<se.length;ye++){const ge=se[ye];this[p].call(this,R,ge.originalDelegate?ge.originalDelegate:ge.callback,ge.options)}}}}else{const W=Object.keys(h);for(let J=0;J<W.length;J++){const ne=Ye.exec(W[J]);let re=ne&&ne[1];re&&"removeListener"!==re&&this[Z].call(this,re)}this[Z].call(this,"removeListener")}if(he)return this},S($[f],ae),S($[p],K),qe&&S($[Z],qe),Ze&&S($[j],Ze),!0}let ve=[];for(let ee=0;ee<u.length;ee++)ve[ee]=Re(u[ee],c);return ve}function ut(e,n){if(!n){const p=[];for(let j in e){const Z=Ye.exec(j);let Q=Z&&Z[1];if(Q&&(!n||Q===n)){const X=e[j];if(X)for(let z=0;z<X.length;z++)p.push(X[z])}}return p}let u=L[n];u||(ot(n),u=L[n]);const c=e[u[je]],f=e[u[Me]];return c?f?c.concat(f):c.slice():f?f.slice():[]}function lt(e,n){const u=e.Event;u&&u.prototype&&n.patchMethod(u.prototype,"stopImmediatePropagation",c=>function(f,p){f[it]=!0,c&&c.apply(f,p)})}function pt(e,n,u,c,f){const p=Zone.__symbol__(c);if(n[p])return;const j=n[p]=n[c];n[c]=function(Z,Q,X){return Q&&Q.prototype&&f.forEach(function(z){const oe=`${u}.${c}::`+z,ie=Q.prototype;try{if(ie.hasOwnProperty(z)){const ce=e.ObjectGetOwnPropertyDescriptor(ie,z);ce&&ce.value?(ce.value=e.wrapWithCurrentZone(ce.value,oe),e._redefineProperty(Q.prototype,z,ce)):ie[z]&&(ie[z]=e.wrapWithCurrentZone(ie[z],oe))}else ie[z]&&(ie[z]=e.wrapWithCurrentZone(ie[z],oe))}catch{}}),j.call(n,Z,Q,X)},e.attachOriginToPatched(n[c],j)}function ft(e,n,u){if(!u||0===u.length)return n;const c=u.filter(p=>p.target===e);if(!c||0===c.length)return n;const f=c[0].ignoreProperties;return n.filter(p=>-1===f.indexOf(p))}function s(e,n,u,c){e&&E(e,ft(e,n,u),c)}function o(e){return Object.getOwnPropertyNames(e).filter(n=>n.startsWith("on")&&n.length>2).map(n=>n.substring(2))}Zone.__load_patch("util",(e,n,u)=>{const c=o(e);u.patchOnProperties=E,u.patchMethod=V,u.bindArguments=Xe,u.patchMacroTask=w;const f=n.__symbol__("BLACK_LISTED_EVENTS"),p=n.__symbol__("UNPATCHED_EVENTS");e[p]&&(e[f]=e[p]),e[f]&&(n[f]=n[p]=e[f]),u.patchEventPrototype=lt,u.patchEventTarget=ct,u.isIEOrEdge=k,u.ObjectDefineProperty=Ge,u.ObjectGetOwnPropertyDescriptor=xe,u.ObjectCreate=He,u.ArraySlice=et,u.patchClass=N,u.wrapWithCurrentZone=Qe,u.filterProperties=ft,u.attachOriginToPatched=S,u._redefineProperty=Object.defineProperty,u.patchCallbacks=pt,u.getGlobalObjects=()=>({globalSources:Ee,zoneSymbolEventNames:L,eventNames:c,isBrowser:m,isMix:y,isNode:l,TRUE_STR:Me,FALSE_STR:je,ZONE_SYMBOL_PREFIX:Ve,ADD_EVENT_LISTENER_STR:Be,REMOVE_EVENT_LISTENER_STR:We})});const x=ue("zoneTask");function H(e,n,u,c){let f=null,p=null;u+=c;const j={};function Z(X){const z=X.data;return z.args[0]=function(){return X.invoke.apply(this,arguments)},z.handleId=f.apply(e,z.args),X}function Q(X){return p.call(e,X.data.handleId)}f=V(e,n+=c,X=>function(z,oe){if("function"==typeof oe[0]){const ie={isPeriodic:"Interval"===c,delay:"Timeout"===c||"Interval"===c?oe[1]||0:void 0,args:oe},ce=oe[0];oe[0]=function(){try{return ce.apply(this,arguments)}finally{ie.isPeriodic||("number"==typeof ie.handleId?delete j[ie.handleId]:ie.handleId&&(ie.handleId[x]=null))}};const ke=nt(n,oe[0],ie,Z,Q);if(!ke)return ke;const fe=ke.data.handleId;return"number"==typeof fe?j[fe]=ke:fe&&(fe[x]=ke),fe&&fe.ref&&fe.unref&&"function"==typeof fe.ref&&"function"==typeof fe.unref&&(ke.ref=fe.ref.bind(fe),ke.unref=fe.unref.bind(fe)),"number"==typeof fe||fe?fe:ke}return X.apply(e,oe)}),p=V(e,u,X=>function(z,oe){const ie=oe[0];let ce;"number"==typeof ie?ce=j[ie]:(ce=ie&&ie[x],ce||(ce=ie)),ce&&"string"==typeof ce.type?"notScheduled"!==ce.state&&(ce.cancelFn&&ce.data.isPeriodic||0===ce.runCount)&&("number"==typeof ie?delete j[ie]:ie&&(ie[x]=null),ce.zone.cancelTask(ce)):X.apply(e,oe)})}Zone.__load_patch("legacy",e=>{const n=e[Zone.__symbol__("legacyPatch")];n&&n()}),Zone.__load_patch("timers",e=>{const n="set",u="clear";H(e,n,u,"Timeout"),H(e,n,u,"Interval"),H(e,n,u,"Immediate")}),Zone.__load_patch("requestAnimationFrame",e=>{H(e,"request","cancel","AnimationFrame"),H(e,"mozRequest","mozCancel","AnimationFrame"),H(e,"webkitRequest","webkitCancel","AnimationFrame")}),Zone.__load_patch("blocking",(e,n)=>{const u=["alert","prompt","confirm"];for(let c=0;c<u.length;c++)V(e,u[c],(p,j,Z)=>function(Q,X){return n.current.run(p,e,X,Z)})}),Zone.__load_patch("EventTarget",(e,n,u)=>{(function Te(e,n){n.patchEventPrototype(e,n)})(e,u),function _e(e,n){if(Zone[n.symbol("patchEventTarget")])return;const{eventNames:u,zoneSymbolEventNames:c,TRUE_STR:f,FALSE_STR:p,ZONE_SYMBOL_PREFIX:j}=n.getGlobalObjects();for(let Q=0;Q<u.length;Q++){const X=u[Q],ie=j+(X+p),ce=j+(X+f);c[X]={},c[X][p]=ie,c[X][f]=ce}const Z=e.EventTarget;Z&&Z.prototype&&n.patchEventTarget(e,n,[Z&&Z.prototype])}(e,u);const c=e.XMLHttpRequestEventTarget;c&&c.prototype&&u.patchEventTarget(e,u,[c.prototype])}),Zone.__load_patch("MutationObserver",(e,n,u)=>{N("MutationObserver"),N("WebKitMutationObserver")}),Zone.__load_patch("IntersectionObserver",(e,n,u)=>{N("IntersectionObserver")}),Zone.__load_patch("FileReader",(e,n,u)=>{N("FileReader")}),Zone.__load_patch("on_property",(e,n,u)=>{!function _(e,n){if(l&&!y||Zone[e.symbol("patchEvents")])return;const u=n.__Zone_ignore_on_properties;let c=[];if(m){const f=window;c=c.concat(["Document","SVGElement","Element","HTMLElement","HTMLBodyElement","HTMLMediaElement","HTMLFrameSetElement","HTMLFrameElement","HTMLIFrameElement","HTMLMarqueeElement","Worker"]);const p=function A(){try{const e=Fe.navigator.userAgent;if(-1!==e.indexOf("MSIE ")||-1!==e.indexOf("Trident/"))return!0}catch{}return!1}()?[{target:f,ignoreProperties:["error"]}]:[];s(f,o(f),u&&u.concat(p),Ne(f))}c=c.concat(["XMLHttpRequest","XMLHttpRequestEventTarget","IDBIndex","IDBRequest","IDBOpenDBRequest","IDBDatabase","IDBTransaction","IDBCursor","WebSocket"]);for(let f=0;f<c.length;f++){const p=n[c[f]];p&&p.prototype&&s(p.prototype,o(p.prototype),u)}}(u,e)}),Zone.__load_patch("customElements",(e,n,u)=>{!function Ce(e,n){const{isBrowser:u,isMix:c}=n.getGlobalObjects();(u||c)&&e.customElements&&"customElements"in e&&n.patchCallbacks(n,e.customElements,"customElements","define",["connectedCallback","disconnectedCallback","adoptedCallback","attributeChangedCallback"])}(e,u)}),Zone.__load_patch("XHR",(e,n)=>{!function Q(X){const z=X.XMLHttpRequest;if(!z)return;const oe=z.prototype;let ce=oe[Oe],ke=oe[tt];if(!ce){const M=X.XMLHttpRequestEventTarget;if(M){const ae=M.prototype;ce=ae[Oe],ke=ae[tt]}}const fe="readystatechange",Re="scheduled";function ve(M){const ae=M.data,K=ae.target;K[p]=!1,K[Z]=!1;const Ze=K[f];ce||(ce=K[Oe],ke=K[tt]),Ze&&ke.call(K,fe,Ze);const qe=K[f]=()=>{if(K.readyState===K.DONE)if(!ae.aborted&&K[p]&&M.state===Re){const Se=K[n.__symbol__("loadfalse")];if(0!==K.status&&Se&&Se.length>0){const Le=M.invoke;M.invoke=function(){const De=K[n.__symbol__("loadfalse")];for(let Pe=0;Pe<De.length;Pe++)De[Pe]===M&&De.splice(Pe,1);!ae.aborted&&M.state===Re&&Le.call(M)},Se.push(M)}else M.invoke()}else!ae.aborted&&!1===K[p]&&(K[Z]=!0)};return ce.call(K,fe,qe),K[u]||(K[u]=M),$.apply(K,ae.args),K[p]=!0,M}function ee(){}function U(M){const ae=M.data;return ae.aborted=!0,me.apply(ae.target,ae.args)}const Ae=V(oe,"open",()=>function(M,ae){return M[c]=0==ae[2],M[j]=ae[1],Ae.apply(M,ae)}),we=ue("fetchTaskAborting"),he=ue("fetchTaskScheduling"),$=V(oe,"send",()=>function(M,ae){if(!0===n.current[he]||M[c])return $.apply(M,ae);{const K={target:M,url:M[j],isPeriodic:!1,args:ae,aborted:!1},Ze=nt("XMLHttpRequest.send",ee,K,ve,U);M&&!0===M[Z]&&!K.aborted&&Ze.state===Re&&Ze.invoke()}}),me=V(oe,"abort",()=>function(M,ae){const K=function ie(M){return M[u]}(M);if(K&&"string"==typeof K.type){if(null==K.cancelFn||K.data&&K.data.aborted)return;K.zone.cancelTask(K)}else if(!0===n.current[we])return me.apply(M,ae)})}(e);const u=ue("xhrTask"),c=ue("xhrSync"),f=ue("xhrListener"),p=ue("xhrScheduled"),j=ue("xhrURL"),Z=ue("xhrErrorBeforeScheduled")}),Zone.__load_patch("geolocation",e=>{e.navigator&&e.navigator.geolocation&&function a(e,n){const u=e.constructor.name;for(let c=0;c<n.length;c++){const f=n[c],p=e[f];if(p){if(!r(xe(e,f)))continue;e[f]=(Z=>{const Q=function(){return Z.apply(this,Xe(arguments,u+"."+f))};return S(Q,Z),Q})(p)}}}(e.navigator.geolocation,["getCurrentPosition","watchPosition"])}),Zone.__load_patch("PromiseRejectionEvent",(e,n)=>{function u(c){return function(f){ut(e,c).forEach(j=>{const Z=e.PromiseRejectionEvent;if(Z){const Q=new Z(c,{promise:f.promise,reason:f.rejection});j.invoke(Q)}})}}e.PromiseRejectionEvent&&(n[ue("unhandledPromiseRejectionHandler")]=u("unhandledrejection"),n[ue("rejectionHandledHandler")]=u("rejectionhandled"))}),Zone.__load_patch("queueMicrotask",(e,n,u)=>{!function P(e,n){n.patchMethod(e,"queueMicrotask",u=>function(c,f){Zone.current.scheduleMicroTask("queueMicrotask",f[0])})}(e,u)})}},xe=>{xe(xe.s=253)}]);